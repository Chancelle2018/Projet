# -*- coding: utf-8 -*-
"""simplexProgramming.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1aaxLJ-XvkHNnYsssoueWvkXV85-JKgMN
"""

import numpy as np
import pandas as pd

# Shanelle Kizima
# 11/01/2022
# Simplex Programming Projecct

def crea_matrice(param1,param2):
    #Créer et remplir la matrice
    print(param1)
    print(param2)


class LinearP() :
    
    def __init__(self):
        #coef_v -> varWeights
        self.varWeights=[]                    #coefficient  les variables de l'équation du problème liste de réels

        #coef_c
        self.constraintWeights=[]                   #coefficient devant les variables dans les contraintes liste de liste de réel

        self.nbFeatures=0                            #nombre de variables int

        self.constraintsNumber=0  #nombre de contraintes int

        self.problemeType=""#type de problème str

        self.listConstraint=[]      #type de contrainte liste de str

        self.y0=[]#

    
    def inputInformation(self, message, isFloat=True):
        if isFloat==True:
            return float(input(message))
        else:
            return input(message)
    def type_prb(self):
        message = "----------------------  Veuillez entrer le type de problème (max ou min): ---------------------------- \n"
        self.problemeType=self.inputInformation(message, isFloat=False)
        
     
    def objectiveFunction(self):
        print("------------------------------------------- \n ------------------------------------------- \n ")
        self.problemeType = self.inputInformation("Veuillez entrer le type de problème (max ou min) : ", float=False)

    def variables(self):
            message = " ++++++++++++++++++++++ Combien y a-t-il de variables?: ++++++++++++++++++++++ \n"

            self.nbFeatures=self.inputInformation(message)
            self.varWeights = [self.inputInformation("Donnez la valeur du coefficient de la variable n°"+str(varIndex+1)+" : ") 
            for varIndex in range(int(self.nbFeatures))]
            return self.nbFeatures


    def contraintes(self):
        message = " ++++++++++++++++++++++ Combien y a-t-il de contraintes?: ++++++++++++++++++++++ \n"

        #self.nb_c=int(input("Combien y a-t-il de contraintes ? "))
        self.constraintsNumber=self.inputInformation(message, isFloat=True)
        print("------------------------------------------\n----------------------------------------------------")
        self.listConstraint = [(self.inputInformation("Type de la contrainte n°"+str(varIndex+1)+" (inferieur: <=, superieur: >= ) : ", isFloat=False)) 
        for varIndex in range(int(self.constraintsNumber))]
        #control de la saisie de l'utilisateur
        for constraint in  self.listConstraint:
            if constraint not in ["<=", ">="]:
                print("S'il vous plait, choisissez uniquement entre <= ou >=, \n les autres symboles ou nombres ne sont pas autorisés. Merci")
                self.listConstraint = [(self.inputInformation("Type de la contrainte n°"+str(varIndex+1)+" (inferieur: <=, superieur: >= ) : ", isFloat=False)) 
                for varIndex in range(int(self.constraintsNumber))]


        for varIndex in range (int(self.constraintsNumber)):
            coefficients=[]
            coefficients = [(self.inputInformation("Donnez la valeur du coefficient de la variable n° "+str(varIndex+1)+" : \n", isFloat=True)) 
                for varIndex in range (int(self.nbFeatures))]

            self.constraintWeights.append(coefficients)

            self.y0.append(self.inputInformation(str(self.listConstraint[varIndex])+" à ? : ", isFloat=True))
        print()
        print()
        print("------------------------------------------ Résultat d'optimisations  ----------------------------------------------------")




class matrice ():

    def __init__(self,varWeights,constraintWeights):
        self.superior = ">="
        self.inferior = "<="
        
        self.m=[]


        self.mv=-(np.array(varWeights))

        self.mc=constraintWeights
    
    def  superiorOrInferior(self, listConstraint, mc, constraintsNumber, mv) :
        self.mv = self.mv
        self.mc = self.mc
        for i in range(int(constraintsNumber)): 
            self.mv=np.append(self.mv,0)
            self.mc[i].append(1) if listConstraint[i]==self.inferior else self.mc[i].append(-1)
            for j in range (int(constraintsNumber)):
                if j!=i:
                    self.mc[j].append(0)
        return self.mv, self.mc
    
    def standard(self,varWeights,constraintWeights,nbFeatures,constraintsNumber,problemeType,listConstraint,y0):
            self.mv, self.mc = self.superiorOrInferior(listConstraint, self.mc, constraintsNumber, self.mv)
            for i in range(int(constraintsNumber)):
                self.mc[i].append(0) 
                self.mc[i].append(y0[i])
            self.mv=np.append(self.mv,1)  
            self.mv=np.append(self.mv,0)
            self.m=np.vstack((self.mv,self.mc))

   



def simplex():
    print("** * * * * * * * * * * * * * * WELCOME IN LINEAR  * * * * * * * * * * * * * * **")
    print("** * * * * * * * * * * * * * * PROGRAMMING  * * * * * * * * * * * * * * **")
    print("** * * * * * * * * * * * * * * SOLVER  * * * * * * * * * * * * * * **")

    prob=LinearP() 

    prob.type_prb()

    prob.variables()

    prob.contraintes()

    varWeights=prob.varWeights

    constraintWeights=prob.constraintWeights

    nbFeatures=prob.nbFeatures

    constraintsNumber=prob.constraintsNumber

    problemeType=prob.problemeType

    listConstraint=prob.listConstraint

    y0=prob.y0

    matrix=matrice(varWeights,constraintWeights)

    matrix.standard(varWeights,constraintWeights,nbFeatures,constraintsNumber,problemeType,listConstraint,y0) 

    Matrice=matrix.m  

    (line,column)=np.shape(Matrice)           #(lignes,colonnes)



    b_nb={}

    j=0

    i=0

    Z=0


    numberCol = column-3
    while min(Matrice[0,0:numberCol])<0:   #condition pour rentrer dans l'algorithme simplex

        #On détermine le pivot

        eq0=Matrice[0,:] #premiere ligne 
         #y = last_column
        lastcolumn=(Matrice[:,numberCol+2])#dernière colonne

        indexcolonnePivot=np.argmax(eq0[0:numberCol]==min(eq0[0:numberCol])) #indice colonne pivot 

        colonnePivot=Matrice[:,indexcolonnePivot]#colonne du pivot

        div=[col1 / col2 for col1, col2 in zip(lastcolumn, colonnePivot)]#division de la dernière colonne par la colonne du pivot

        indexlignePivot=div.index(min(div[1:line]))#indice ligne pivot

        lignePivot=Matrice[indexlignePivot,:]#ligne pivot  

        pivot=Matrice[indexlignePivot,indexcolonnePivot]#yess on a determiné le pivot

        print("pivot=",pivot)

        

        #Calculs

        for i in range(int(line)):

            if i!=indexlignePivot:  #si on est pas sur la ligne du pivot

                Matrice[i,:]=Matrice[i,:]-(Matrice[i,indexcolonnePivot]/pivot)*lignePivot       #Ligne n°i (Li) =Li- (coef Li de la cp)/p*lp

            else : #si on est sur la ligne du pivot

                Matrice[indexlignePivot,:]=Matrice[indexlignePivot,:]/pivot

                

        #Resultats après calculs       

        while j<=(numberCol+2):#on parcourt les colonnes

            if Matrice[i,j]!=0 and Matrice[i,j]!=1 : #pour une colonne fixe pour la ligne i on vérifie si c'est basique ou pas

                print("la variable X",j,"est une variable non basique")

                b_nb[j]='nb'

                j+=1

            elif i==line-1 : #si on a vérifié pour toutes les lignes et que c'est ok alors la variables est basique, on change de colonne

                print("la variable X",j,"est une variable basique")

                b_nb[j]='b'

                j+=1

                i=0

            else : #si on a pas vérifié pour toutes les ligne on passe à la ligne suivante

                i+=1

        

        y0=Matrice[0,numberCol+2] #premier element de la dernière colonne

        for j in range(int(numberCol+2)):#calcul de Z solution finale

            if b_nb[j]=='nb':#si une variable est non basique

                Z=y0

            elif b_nb[j]=='b' and j!=numberCol+1 :

                Z=y0-Matrice[0,j]

    nom_v=[]

    equation=""

    contrainte=[]

    for i in range(int(prob.nbFeatures)):

        nom_v.append("X"+str(i+1))

        equation+=" + "+str(prob.varWeights[i])+nom_v[i]

    for i in range(int(prob.constraintsNumber)):

        c=""

        for j in range(int(prob.nbFeatures)):

            c+=" + "+str(prob.constraintWeights[i][j])+nom_v[j]

        contrainte.append(c)

        

    print("-----------------------------------------------")

    print("\nProblème de ",prob.problemeType,"d'équation : Z =",equation) 

    print("\nSous contrainte ") 

    for i in range(int(prob.constraintsNumber)):

        print(contrainte[i],prob.listConstraint[i],prob.y0[i])

    print("-----------------------------------------------")
    print()
    print()

    print ("M=",pd.DataFrame(data=Matrice).head())
    print()
    print()
    #Mat = Matrice
    print("** * * * * * * * * * * * * * * Z OPTIMAL = {}  * * * * * * * * * * * * * * **".format(Z))
    print("------------------------------- END OF SOLVER -------------------------------------")
    
#simplex()